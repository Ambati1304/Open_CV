//#include "opencv2/imgcodecs.hpp"#include "opencv2/core/core.hpp"#include "opencv2/imgcodecs.hpp"#include "opencv2/highgui/highgui.hpp"#include <iostream>#include "opencv2/imgproc/imgproc.hpp"using namespace cv;using namespace std;Mat image1 = imread("inp1.jpg", 0);Mat image2 = imread("inp2.jpg", 0);int l1 = image1.rows * image1.cols;int l2 = image2.rows * image2.cols;int *x1 = new int[l1];int *x2 = new int[l2];int main(int, char** argv){	Mat img1(280, 280, CV_8UC3, Scalar(255, 255, 255));	int a = 0;	for (int i = 0; i < image1.rows; i++)	{		for (int j = 0; j < image1.cols; j++)		{			x1[a] = image1.at<uchar>(i, j);			x2[a] = image2.at<uchar>(i, j);			img1.at<Vec3b>(x1[a], x2[a])[0] = 255;			img1.at<Vec3b>(x1[a], x2[a])[1] = 0;			img1.at<Vec3b>(x1[a], x2[a])[2] = 0;			a++;		}	}	vector<Point> data1;	Vec4f lines1;	Vec4f lines1_Fair;	Vec4f lines1_Welsch;	Vec4f lines1_Huber;		for (int i = 0; i < l1; i++)	{		data1.push_back(Point(x2[i], x1[i]));	}	// Gaussian Estimation	double Sumx1 = 0;	double Sumy1 = 0;	double Meanx1 = 0;	double Meany1 = 0;	double Sumxy1 = 0;	double Sumxx1 = 0;	double Sumyy1 = 0;	double covariance_xx1 = 0;	double covariance_yy1 = 0;	double covariance_xy1 = 0;	double start_angle = 0;	double end_angle = 360;	double angle1 = 0;	for (int i = 0; i < l1; i++)	{		Sumx1 = Sumx1 + x2[i];		Sumy1 = Sumy1 + x1[i];	}Meanx1 = Sumx1 / l2;	Meany1 = Sumy1 / l1;	cout << "Meanx:" << Meanx1 << "Mean:" << Meany1 << endl;	for (int i = 0; i < l1; i++)	{		Sumxy1 = Sumxy1 + ((x2[i] - Meanx1)*(x1[i] - Meany1));		Sumxx1 = Sumxx1 + ((x2[i] - Meanx1)*(x2[i] - Meanx1));		Sumyy1 = Sumyy1 + ((x1[i] - Meany1)*(x1[i] - Meany1));	}	covariance_xx1 = Sumxx1 / l1;	covariance_xy1 = Sumxy1 / l1;	covariance_yy1 = Sumyy1 / l1;	Mat covmat_1 = (Mat_<double>(2, 2) << covariance_xx1, covariance_xy1, covariance_xy1, covariance_yy1);	cout << covmat_1 << endl;	Mat eigenvalues_1, eigenvectors_1;	eigen(covmat_1, eigenvalues_1, eigenvectors_1);	cout << "eigenvalues_1: " << eigenvectors_1 << endl;	cout << "eigenvectors_1: " << eigenvalues_1 << endl;	double angle = atan2(eigenvectors_1.at<double>(0, 1), eigenvectors_1.at<double>(0, 0));	if (angle < 0)		angle += 6.28318530718;	angle1 = angle;	angle = 180 * angle / 3.14159265359;	cout << "angle: " << angle << endl;	double halfmajoraxissize = 5.991*sqrt(eigenvalues_1.at<double>(0));	double halfminoraxissize = 5.991*sqrt(eigenvalues_1.at<double>(1));	// Plotting of ellipse	ellipse(img1, Point((int)Meanx1, (int)Meany1), Size(sqrt(eigenvalues_1.at<double>(0)*5.991), sqrt(eigenvalues_1.at<double>(1)*5.991)), angle, start_angle, end_angle, Scalar(0, 0, 255), 2, 8, 0);			waitKey();	return 0;}